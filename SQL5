                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                              ++++                        JOIN                      ++++ 
                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CREATE table city(
cid int,
cityname varchar(20),
primary key(cid)
);

CREATE table personal(
id int,
name varchar(20),
percentage int,
age int,
gender varchar(10),
city int,
foreign key(city) references city(cid)
);

mysql> desc city;
+----------+-------------+------+-----+---------+-------+
| Field    | Type        | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| cid      | int(11)     | NO   | PRI | NULL    |       |
| cityname | varchar(20) | YES  |     | NULL    |       |
+----------+-------------+------+-----+---------+-------+
2 rows in set (0.01 sec)


mysql> desc personal;
+------------+-------------+------+-----+---------+-------+
| Field      | Type        | Null | Key | Default | Extra |
+------------+-------------+------+-----+---------+-------+
| id         | int(11)     | YES  |     | NULL    |       |
| name       | varchar(20) | YES  |     | NULL    |       |
| percentage | int(11)     | YES  |     | NULL    |       |
| age        | int(11)     | YES  |     | NULL    |       |
| gender     | varchar(10) | YES  |     | NULL    |       |
| city       | int(11)     | YES  | MUL | NULL    |       |
+------------+-------------+------+-----+---------+-------+
6 rows in set (0.00 sec)


INSERT INTO city values(1,'Agra'),(2,'Delhi'),(3,'Bhopal'),(4,'Jaipur'),(5,'Noida');

INSERT INTO personal values(1,'Ram',45,19,'M',1),
(2,'Sarita',55,22,'F',2),
(3,'Salman',62,20,'M',1),
(4,'Juhi',47,18,'F',3),
(5,'Anil',74,22,'M',1),
(6,'John',64,21,'M',2),
(7,'Sahid',52,20,'M',1);

mysql> select*from personal;
+------+--------+------------+------+--------+------+
| id   | name   | percentage | age  | gender | city |
+------+--------+------------+------+--------+------+
|    1 | Ram    |         45 |   19 | M      |    1 |
|    2 | Sarita |         55 |   22 | F      |    2 |
|    3 | Salman |         62 |   20 | M      |    1 |
|    4 | Juhi   |         47 |   18 | F      |    3 |
|    5 | Anil   |         74 |   22 | M      |    1 |
|    6 | John   |         64 |   21 | M      |    2 |
|    7 | Sahid  |         52 |   20 | M      |    1 |
+------+--------+------------+------+--------+------+
7 rows in set (0.00 sec)


mysql> SELECT * from personal INNER JOIN city ON personal.city=city.cid;
+------+--------+------------+------+--------+------+-----+----------+
| id   | name   | percentage | age  | gender | city | cid | cityname |
+------+--------+------------+------+--------+------+-----+----------+
|    1 | Ram    |         45 |   19 | M      |    1 |   1 | Agra     |
|    3 | Salman |         62 |   20 | M      |    1 |   1 | Agra     |
|    5 | Anil   |         74 |   22 | M      |    1 |   1 | Agra     |
|    7 | Sahid  |         52 |   20 | M      |    1 |   1 | Agra     |
|    2 | Sarita |         55 |   22 | F      |    2 |   2 | Delhi    |
|    6 | John   |         64 |   21 | M      |    2 |   2 | Delhi    |
|    4 | Juhi   |         47 |   18 | F      |    3 |   3 | Bhopal   |
+------+--------+------------+------+--------+------+-----+----------+
7 rows in set (0.00 sec)

-- You can see jaipur, nodia is not there in the output.

SELECT personal.name,personal.percentage,personal.age,personal.gender,city.cityname from personal  INNER JOIN city ON pe
rsonal.city=city.cid;

                                                         OR

SELECT p.name,p.percentage,p.age,p.gender,c.cityname from personal as p INNER JOIN city as c ON p.city=c.cid;
(note: now you cannot write city/personal in place of c/p).

+--------+------------+------+--------+----------+
| name   | percentage | age  | gender | cityname |
+--------+------------+------+--------+----------+
| Ram    |         45 |   19 | M      | Agra     |
| Salman |         62 |   20 | M      | Agra     |
| Anil   |         74 |   22 | M      | Agra     |
| Sahid  |         52 |   20 | M      | Agra     |
| Sarita |         55 |   22 | F      | Delhi    |
| John   |         64 |   21 | M      | Delhi    |
| Juhi   |         47 |   18 | F      | Bhopal   |
+--------+------------+------+--------+----------+
7 rows in set (0.00 sec)



                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                              ++++                   LEFT JOIN                      ++++ 
                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Left join return all records form left table and return matching records form right table.


CREATE table personal(
id int,
name varchar(20),
age int,
city int
);


mysql> delete from personal;
Query OK, 7 rows affected (0.11 sec)

mysql> delete from city;
Query OK, 5 rows affected (0.04 sec)


INSERT INTO city values(1,'Agra'),(2,'Bhopal'),(3,'Delhi'),(4,'Noida');

INSERT INTO personal(id,name,age,city) values(1,'Ram',19,1),
(2,'Salman',18,2),
(3,'Meera',19,null),
(4,'Sarita',21,3);


mysql> desc personal;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| id    | int(11)     | YES  |     | NULL    |       |
| name  | varchar(20) | YES  |     | NULL    |       |
| age   | int(11)     | YES  |     | NULL    |       |
| city  | int(11)     | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
4 rows in set (0.00 sec)

mysql> select*from city;
+-----+----------+
| cid | cityname |
+-----+----------+
|   1 | Agra     |
|   2 | Bhopal   |
|   3 | Delhi    |
|   4 | Noida    |
+-----+----------+
4 rows in set (0.00 sec)


mysql> select*from personal;
+------+--------+------+------+
| id   | name   | age  | city |
+------+--------+------+------+
|    1 | Ram    |   19 |    1 |
|    2 | Salman |   18 |    2 |
|    3 | Meera  |   19 | NULL |
|    4 | Sarita |   21 |    3 |
+------+--------+------+------+
4 rows in set (0.01 sec)



SELECT * from personal LEFT JOIN city ON personal.city=city.cid;
+------+--------+------+------+------+----------+
| id   | name   | age  | city | cid  | cityname |
+------+--------+------+------+------+----------+
|    1 | Ram    |   19 |    1 |    1 | Agra     |
|    2 | Salman |   18 |    2 |    2 | Bhopal   |
|    4 | Sarita |   21 |    3 |    3 | Delhi    |
|    3 | Meera  |   19 | NULL | NULL | NULL     |
+------+--------+------+------+------+----------+
4 rows in set (0.00 sec)


                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                              ++++                  RIGHT JOIN                      ++++ 
                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Return all records from right table and matching records form left table.

mysql> SELECT * from personal RIGHT JOIN city ON personal.city=city.cid;
+------+--------+------+------+-----+----------+
| id   | name   | age  | city | cid | cityname |
+------+--------+------+------+-----+----------+
|    1 | Ram    |   19 |    1 |   1 | Agra     |
|    2 | Salman |   18 |    2 |   2 | Bhopal   |
|    4 | Sarita |   21 |    3 |   3 | Delhi    |
| NULL | NULL   | NULL | NULL |   4 | Noida    |
+------+--------+------+------+-----+----------+
4 rows in set (0.00 sec)



                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                              ++++                  CROSS JOIN                      ++++ 
                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

mysql> SELECT * from personal CROSS JOIN city;

mysql> SELECT * from personal CROSS JOIN city;
+------+--------+------+------+-----+----------+
| id   | name   | age  | city | cid | cityname |
+------+--------+------+------+-----+----------+
|    1 | Ram    |   19 |    1 |   1 | Agra     |
|    2 | Salman |   18 |    2 |   1 | Agra     |
|    3 | Meera  |   19 | NULL |   1 | Agra     |
|    4 | Sarita |   21 |    3 |   1 | Agra     |
|    1 | Ram    |   19 |    1 |   2 | Bhopal   |
|    2 | Salman |   18 |    2 |   2 | Bhopal   |
|    3 | Meera  |   19 | NULL |   2 | Bhopal   |
|    4 | Sarita |   21 |    3 |   2 | Bhopal   |
|    1 | Ram    |   19 |    1 |   3 | Delhi    |
|    2 | Salman |   18 |    2 |   3 | Delhi    |
|    3 | Meera  |   19 | NULL |   3 | Delhi    |
|    4 | Sarita |   21 |    3 |   3 | Delhi    |
|    1 | Ram    |   19 |    1 |   4 | Noida    |
|    2 | Salman |   18 |    2 |   4 | Noida    |
|    3 | Meera  |   19 | NULL |   4 | Noida    |
|    4 | Sarita |   21 |    3 |   4 | Noida    |
+------+--------+------+------+-----+----------+
16 rows in set (0.00 sec)




                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                              ++++               Having vs Where                    ++++ 
                                              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

I want to get no of students from source_of_joining table
select source_of_joining,count(*) from students group by source_of_joining;

+-------------------+----------+
| source_of_joining | count(*) |
+-------------------+----------+
| friend            |        1 |
| google            |        1 |
| linknedin         |        2 |
| quora             |        1 |
| youtube           |        2 |
+-------------------+----------+
5 rows in set (0.00 sec)


I want to display where more than 1 person has registered.

select source_of_joining,count(*) from students group by source_of_joining where total>1;
error.

where can be used group by(it is good to filter individual records before aggregation);

WE can use having.
(it is used ot filter records after grouping has happned)

mysql> select source_of_joining,count(*) as total from students group by source_of_joining having total>1;
+-------------------+-------+
| source_of_joining | total |
+-------------------+-------+
| linknedin         |     2 |
| youtube           |     2 |
+-------------------+-------+
2 rows in set (0.00 sec)

where is used before the aggregation and having is used after the aggregation.


select source_of_joining,count(*) as total from students group by source_of_joining having source_of_joining='linknedin;
+-------------------+-------+
| source_of_joining | total |
+-------------------+-------+
| linknedin         |     2 |
+-------------------+-------+
1 row in set (0.00 sec)
where will give error.



It could be better if we do this way
(i am filtering individual records before even doing complex work like aggregation)
select source_of_joining,count(*) as total from students where source_of_joining='linknedin group by source_of_joining;


mysql> select source_of_joining,count(*) as total from students where source_of_joining='linknedin' group by source_of_joining;
+-------------------+-------+
| source_of_joining | total |
+-------------------+-------+
| linknedin         |     2 |
+-------------------+-------+
1 row in set (0.00 sec)


(more performant)

Can we use where and having in same query?
I want to know location from which 1 students have joined and students experience is > 10.

select location,count(*) as total from students where years_of_exp>10 group by location having total>1;
thought process should be do filtering as early as possible. 


+----------+-------+
| location | total |
+----------+-------+
| pune     |     3 |
+----------+-------+
1 row in set (0.00 sec)


Over Clause

create table employee(
    firstname varchar(20),
    lastname varchar(20),
    age int,
    salary int, 
    location varchar(20)
);

insert into employee values('sachin','sharma',28,10000,'bangalore');

insert into employee values('shane','warne',30,20000,'bangalore');

insert into employee values('rohit','sharma',32,30000,'hyderabad');

insert into employee values('shikar','dhawan',32,25000,'hyderabad');

insert into employee values('rahul','dravid',31,20000,'bangalore');

insert into employee values('saurabh','ganguly',32,15000,pune);

insert into employee values('kapil','dev',34,10000,'pune');

--How many people are from each location and avg salary at each Location--


select location,count(location),avg(salary) from employee group by location;


Output:

location	count(location)	avg(salary)
bangalore	       3	   16666.6667
hyderabad	       2  	   27500.0000
pune	           2	   12500.0000

What if i want something like this?

Output:

firstname	lastname	age	salary	location
sachin	sharma	bangalore	       3	   16666.6667
shane	warne	bangalore	       3	   16666.6667
rohit	sharma	hyderabad	       2  	   27500.0000
shikar	dhawan	hyderabad	       2  	   27500.0000
rahul	dravid	bangalore	       3	   16666.6667
saurabh	ganguly	pune	           2	   12500.0000
kapil	dev	34	pune	           2	   12500.0000




select firstname,lastname,location,count(location),avg(salary) from employee group by location;

ERROR 1055 (42000) at line 26: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 
'db_3ygdt2a3e.employee.firstname' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with
sql_mode=only_full_group_by




We can try it using join...


select firstname,lastname,location,total_count,avg_salary from employee join 
(select location,count(location),avg(salary) from employee group by location) temptable on employee.location=temptable.location;

AS location column is present in both tables it will show ambiguity. 
ERROR 1052 (23000) at line 32: Column 'location' in field list is ambiguous


select firstname,lastname,employee.location,total_count,avg_salary from employee join 
(select location,count(location) as total_count,avg(salary) as avg_salary from employee group by location) temptable on employee.location=temptable.location;


firstname	lastname	location	total_count	avg_salary
sachin	sharma	bangalore	3	16666.6667
shane	warne	bangalore	3	16666.6667
rohit	sharma	hyderabad	2	27500.0000
shikar	dhawan	hyderabad	2	27500.0000
rahul	dravid	bangalore	3	16666.6667
saurabh	ganguly	pune	2	12500.0000
kapil	dev	pune	2	12500.0000


---Easier way---
Use OVER PARTITION BY to achieve this.

select firstname,lastname,location,count(location) OVER(PARTITION BY location),
avg(salary) OVER (PARTITION BY location) as average from employee;



This is how we use over and partition by to club the non aggregated columns(firstname,lastname,location) along with 
aggregated columns(OVER(PARTITION BY location),avg(salary) OVER (PARTITION BY location)) easliy.



Row Number function
row number cannot work without order by(no point of giving some numbering when you are not ordering it).


I want highest to lowest salary and row numbers starting from 1.

select firstname,lastname,salary,row_number over (order by salary desc) from employee;

firstname	lastname	salary	row_number() over (order by salary desc)
rohit	sharma	        30000	1
shikar	dhawan	        25000	2
shane	warne	        20000	3
rahul	dravid	        20000	4
saurabh	ganguly	        15000	5
sachin	sharma	        10000	6
kapil	dev	            10000	7


Find 5 highest salary.
select * from (select firstname,lastname,salary,row_number() over (order by salary desc) as rownum from employee) temptable where rownum=5;

Output:

firstname	lastname	salary	rownum
saurabh	ganguly	15000	5



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++             RANK AND DESNSE RANK                 ++++ 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


They are use to solve problems of Duplicates in a table.
Order by is mandatory for them also.(partition by is optional)


select firstname,lastname,salary ,row_number() over(order by salary desc) from employee;

each row has diff no.

firstname	lastname	salary	row_number() over(order by salary desc)
rohit	sharma	30000	1
shikar	dhawan	25000	2
shane	warne	20000	3
rahul	dravid	20000	4
saurabh	ganguly	15000	5
sachin	sharma	10000	6
kapil	dev	10000	7


select firstname,lastname,salary ,rank() over(order by salary desc) from employee;

same rank to duplicates.(but it ommited 4)

firstname	lastname	salary	rank() over(order by salary desc)
rohit	sharma	30000	1
shikar	dhawan	25000	2
shane	warne	20000	3
rahul	dravid	20000	3
saurabh	ganguly	15000	5
sachin	sharma	10000	6
kapil	dev	10000	6


select firstname,lastname,salary ,dense_rank() over(order by salary desc) from employee;
(no ranks are skipped)

firstname	lastname	salary	dense_rank() over(order by salary desc)
rohit	sharma	30000	1
shikar	dhawan	25000	2
shane	warne	20000	3
rahul	dravid	20000	3
saurabh	ganguly	15000	4
sachin	sharma	10000	5
kapil	dev	10000	5


Usage of all completely depends on requirements.